"""
This module provides functions for generating and editing personal statement \
by calling OpenAI GPT API.

Dependencies:
    - json
    - streamlit
    - optimizer.utils.extract
    - optimizer.gpt.api
    - optimizer.core.job

Functions:
    - parse_statements(replies: list) -> list:
        Given a list of replies, extracts the code from each reply and
        appends it as a statement to a list of statements.

    - generate_statements(words: int = 120, temperature: float = 0.8) -> list:
        Generates statements by calling OpenAI API using the provided session state parameters.
        Parameteres:
            - words (int): The number of words for the generated statement. Default is 120.
            - temperature (float): Controls the "creativity" of the \
            generated response, with higher temperatures generating more \
            creative responses. Default is 0.8.
        Returns:
            - replies (list): A list of replies generated by the OpenAI API.

    - edit_statement() -> None:
        This function generates a personal statement for the user and allows \
        them to choose between different versions of the generated statement.
        Returns:
            - None

"""
import json
import streamlit as st
from optimizer.core.initialisation import initialise
from optimizer.utils.extract import extract_code
from optimizer.gpt.api import MODEL, call_openai_api, SYSTEM_ROLE

st.set_page_config(
    page_title="Personal Statement",
    page_icon=":open_book:",
)


def parse_statements(replies: list) -> list:
    """
    Given a list of replies, extracts the code from each reply and \
    appends it as a statement to a list of statements.

    Arguments:
    replies -- a list of strings representing replies

    Returns:
    A list of strings representing statements extracted from replies.

    """
    statements = []
    for reply in replies:
        statement = extract_code(reply)
        statements.append(statement)
    return statements


def generate_statements(words: int = 120, temperature: float = 0.8) -> list:
    """
    Generates statements by calling OpenAI API using the provided session state parameters.

    Parameters:
        words (int): The number of words for the generated statement. \
        Default is 120.
        temperature (float): Controls the "creativity" of the generated \
        response, with higher temperatures generating more creative \
        responses. Default is 0.8.

    Returns:
        replies (list): A list of replies generated by the OpenAI API.
    """
    txt_jd = st.session_state['txt_jd']
    skills = st.session_state['skills']
    statement = st.session_state['statement']
    experiences_str = json.dumps(st.session_state['experiences'])

    messages = [
        {"role": "system", "content": SYSTEM_ROLE},
        {"role": "assistant", "content":  "The job description is following:"},
        {"role": "assistant", "content":  txt_jd},
        {"role": "assistant",
            "content":  "Can you tell me about your skills and experiences?"},
        {"role": "user", "content": "I will give you my skills as following:"},
        {"role": "user", "content": skills},
        {"role": "user", "content": "I will give you my experiences as \
        following:"},
        {"role": "user", "content": experiences_str},
        {"role": "user", "content": "I will give you my personal statement \
        as following:"},
        {"role": "user", "content": statement},
        {"role": "user", "content": f"Can you write a new personal \
        statement for me in {words} words, connecting my skills and \
        experiences with the job description?"},
        {"role": "user", "content": "Please always surround the output \
        with code tags by using the following syntax:"},
        {"role": "user", "content": "<code> Your message here </code>"},
    ]
    replies = call_openai_api(MODEL, messages, temperature=temperature,
                              number_completion=3)
    return replies


def edit_statement() -> None:
    """
    This function generates a personal statement for the user and allows \
    them to choose between different versions of the generated statement.

    Returns:
    None
    """
    st.markdown("<h2 style='text-align: center;'>Personal statement</h2>",
                unsafe_allow_html=True)
    st.session_state['statement'] = st.text_area(
        'Personal statement', st.session_state['statement'], height=300)
    col_statement_words, col_statement_temp, col_statement = st.columns([
                                                                        1, 1, 1])
    with col_statement_words:
        statement_words = st.slider("Words", 50, 300, value=120)
    with col_statement_temp:
        statement_temp = st.slider("Temperature", 0.0, 1.0, 0.8)
    with col_statement:
        if st.button('Generate statement'):
            replies = generate_statements(
                statement_words,
                statement_temp
            )
            new_statements = parse_statements(replies)
            st.session_state['new_statements'] = new_statements
            st.session_state['btn_generate_statement'] = True

    if st.session_state['btn_generate_statement']:
        options = []
        option = 'Version ' + str(0)
        options.append(option)
        st.write('### ' + option)
        st.write(st.session_state['statement'])
        for i in range(len(st.session_state['new_statements'])):
            option = 'Version ' + str(i+1)
            options.append(option)
            st.write('### ' + option)
            st.write(st.session_state['new_statements'][i])
        if 'statement_choice' in st.session_state:
            statement_choice_index = options.index(
                st.session_state['statement_choice'])
        else:
            statement_choice_index = 0

        st.session_state['statement_choice'] = st.selectbox(
            'Choose final statement', options, index=statement_choice_index)


initialise()
edit_statement()
